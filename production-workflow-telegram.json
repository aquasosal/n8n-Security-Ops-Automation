{
  "name": "Production: Security Scanner with Telegram",
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Start",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 400]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "target1",
              "name": "target",
              "value": "localhost",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "set-targets",
      "name": "ìŠ¤ìº” ëŒ€ìƒ ì„¤ì •",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [460, 400],
      "notes": "ì—¬ê¸°ì„œ ìŠ¤ìº” ëŒ€ìƒ IP ë³€ê²½"
    },
    {
      "parameters": {
        "command": "=nmap -sV -p 22,80,443,3306,3389,5678,8080 -oX - {{ $json.target }}",
        "options": {}
      },
      "id": "nmap-scan",
      "name": "Nmap ìŠ¤ìº”",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [680, 400],
      "notes": "ì£¼ìš” í¬íŠ¸ ìŠ¤ìº”"
    },
    {
      "parameters": {
        "jsCode": "// ===== Nmap XML Parser (í†µí•© ë²„ì „) =====\n\nconst nmapOutput = $input.first().json.stdout;\n\nfunction parseNmapXML(xmlData) {\n  const hosts = [];\n  const hostRegex = /<host[^>]*>([\\s\\S]*?)<\\/host>/g;\n  let hostMatch;\n  \n  while ((hostMatch = hostRegex.exec(xmlData)) !== null) {\n    const hostBlock = hostMatch[1];\n    const stateMatch = /<status\\s+state=\"([^\"]+)\"/.exec(hostBlock);\n    if (!stateMatch || stateMatch[1] !== 'up') continue;\n    \n    const addressMatch = /<address\\s+addr=\"([^\"]+)\"\\s+addrtype=\"ipv4\"/.exec(hostBlock);\n    const ip = addressMatch ? addressMatch[1] : 'unknown';\n    \n    const ports = [];\n    const portRegex = /<port\\s+protocol=\"([^\"]+)\"\\s+portid=\"([^\"]+)\">([\\s\\S]*?)<\\/port>/g;\n    let portMatch;\n    \n    while ((portMatch = portRegex.exec(hostBlock)) !== null) {\n      const protocol = portMatch[1];\n      const portid = portMatch[2];\n      const portBlock = portMatch[3];\n      \n      const portStateMatch = /<state\\s+state=\"([^\"]+)\"/.exec(portBlock);\n      const state = portStateMatch ? portStateMatch[1] : 'unknown';\n      \n      const serviceMatch = /<service\\s+name=\"([^\"]+)\"(?:\\s+product=\"([^\"]*)\")? ?\\/?>/. exec(portBlock);\n      const service = serviceMatch ? serviceMatch[1] : 'unknown';\n      const product = serviceMatch && serviceMatch[2] ? serviceMatch[2] : '';\n      \n      // ìœ„í—˜ë„ í‰ê°€\n      const criticalPorts = ['22', '23', '3389', '5900', '445'];\n      const dbPorts = ['3306', '5432', '1433', '27017', '6379'];\n      let risk_level = 'low';\n      \n      if (criticalPorts.includes(portid)) risk_level = 'critical';\n      else if (dbPorts.includes(portid)) risk_level = 'high';\n      else if (['80', '443', '8080', '8443'].includes(portid)) risk_level = 'medium';\n      \n      ports.push({\n        port: parseInt(portid),\n        protocol,\n        state,\n        service,\n        product,\n        risk_level\n      });\n    }\n    \n    hosts.push({\n      ip,\n      state: 'up',\n      ports,\n      open_ports_count: ports.filter(p => p.state === 'open').length\n    });\n  }\n  \n  return hosts;\n}\n\nfunction generateStatistics(hosts) {\n  let stats = {\n    total_hosts: hosts.length,\n    total_ports: 0,\n    open_ports: 0,\n    critical_ports: 0,\n    high_ports: 0,\n    medium_ports: 0\n  };\n  \n  hosts.forEach(host => {\n    host.ports.forEach(port => {\n      stats.total_ports++;\n      if (port.state === 'open') {\n        stats.open_ports++;\n        if (port.risk_level === 'critical') stats.critical_ports++;\n        else if (port.risk_level === 'high') stats.high_ports++;\n        else if (port.risk_level === 'medium') stats.medium_ports++;\n      }\n    });\n  });\n  \n  return stats;\n}\n\nfunction generateTelegramMessage(hosts, stats) {\n  let msg = `ğŸ” *Nmap ë³´ì•ˆ ìŠ¤ìº” ì™„ë£Œ*\\n\\n`;\n  msg += `ğŸ“Š *í†µê³„*\\n`;\n  msg += `â€¢ ìŠ¤ìº” í˜¸ìŠ¤íŠ¸: ${stats.total_hosts}ëŒ€\\n`;\n  msg += `â€¢ ì „ì²´ í¬íŠ¸: ${stats.total_ports}ê°œ\\n`;\n  msg += `â€¢ ì—´ë¦° í¬íŠ¸: ${stats.open_ports}ê°œ\\n`;\n  msg += `ğŸ”´ Critical: ${stats.critical_ports}ê°œ\\n`;\n  msg += `ğŸŸ  High: ${stats.high_ports}ê°œ\\n`;\n  msg += `ğŸŸ¡ Medium: ${stats.medium_ports}ê°œ\\n\\n`;\n  \n  if (stats.critical_ports > 0 || stats.high_ports > 0) {\n    msg += `âš ï¸ *ìœ„í—˜ í¬íŠ¸ ìƒì„¸*\\n`;\n    hosts.forEach(host => {\n      const dangerPorts = host.ports.filter(p => \n        p.state === 'open' && ['critical', 'high'].includes(p.risk_level)\n      );\n      \n      if (dangerPorts.length > 0) {\n        msg += `\\nğŸ–¥ ${host.ip}\\n`;\n        dangerPorts.forEach(port => {\n          const icon = port.risk_level === 'critical' ? 'ğŸ”´' : 'ğŸŸ ';\n          msg += `  ${icon} ${port.port}/${port.protocol} - ${port.service}`;\n          if (port.product) msg += ` (${port.product})`;\n          msg += `\\n`;\n        });\n      }\n    });\n  } else {\n    msg += `âœ… ìœ„í—˜ í¬íŠ¸ê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\\n`;\n  }\n  \n  msg += `\\nâ° ${new Date().toLocaleString('ko-KR')}`;\n  \n  return msg;\n}\n\ntry {\n  const hosts = parseNmapXML(nmapOutput);\n  const statistics = generateStatistics(hosts);\n  const telegramMessage = generateTelegramMessage(hosts, statistics);\n  \n  console.log('\\n' + '='.repeat(50));\n  console.log('Nmap ìŠ¤ìº” ì™„ë£Œ - Telegram ì „ì†¡ ì¤€ë¹„');\n  console.log('='.repeat(50));\n  console.log(telegramMessage);\n  \n  return {\n    json: {\n      success: true,\n      scan_time: new Date().toISOString(),\n      target: $input.first().json.target,\n      statistics,\n      hosts,\n      telegram_message: telegramMessage,\n      alert_required: statistics.critical_ports > 0 || statistics.high_ports > 0\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      success: false,\n      error: error.message,\n      timestamp: new Date().toISOString(),\n      telegram_message: `âŒ ìŠ¤ìº” ì‹¤íŒ¨: ${error.message}`\n    }\n  };\n}"
      },
      "id": "parse-results",
      "name": "ê²°ê³¼ ë¶„ì„",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400],
      "notes": "íŒŒì‹± + Telegram ë©”ì‹œì§€ ìƒì„±"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.alert_required }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-alert",
      "name": "ì•Œë¦¼ í•„ìš”?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "=ğŸš¨ *ë³´ì•ˆ ê²½ê³  ë°œìƒ!*\n\n{{ $json.telegram_message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "telegram-alert",
      "name": "ğŸš¨ Telegram ê²½ê³ ",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1340, 300],
      "notes": "Critical/High í¬íŠ¸ ë°œê²¬ ì‹œ ì•Œë¦¼",
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.telegram_message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "telegram-normal",
      "name": "âœ… Telegram ì •ìƒ",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1340, 500],
      "notes": "ì •ìƒ ìŠ¤ìº” ê²°ê³¼ ì•Œë¦¼",
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "summary",
              "name": "scan_summary",
              "value": "={{ $json.alert_required ? 'ALERT' : 'OK' }}",
              "type": "string"
            },
            {
              "id": "target",
              "name": "target",
              "value": "=localhost",
              "type": "string"
            },
            {
              "id": "timestamp",
              "name": "completed_at",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "merge-results",
      "name": "ìµœì¢… ê²°ê³¼",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1560, 400],
      "notes": "DB ì €ì¥ ë˜ëŠ” ë¦¬í¬íŠ¸ ì „ì†¡"
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "ìŠ¤ìº” ëŒ€ìƒ ì„¤ì •",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ìŠ¤ìº” ëŒ€ìƒ ì„¤ì •": {
      "main": [
        [
          {
            "node": "Nmap ìŠ¤ìº”",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Nmap ìŠ¤ìº”": {
      "main": [
        [
          {
            "node": "ê²°ê³¼ ë¶„ì„",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ê²°ê³¼ ë¶„ì„": {
      "main": [
        [
          {
            "node": "ì•Œë¦¼ í•„ìš”?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ì•Œë¦¼ í•„ìš”?": {
      "main": [
        [
          {
            "node": "ğŸš¨ Telegram ê²½ê³ ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "âœ… Telegram ì •ìƒ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸš¨ Telegram ê²½ê³ ": {
      "main": [
        [
          {
            "node": "ìµœì¢… ê²°ê³¼",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "âœ… Telegram ì •ìƒ": {
      "main": [
        [
          {
            "node": "ìµœì¢… ê²°ê³¼",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {},
  "versionId": "1"
}
