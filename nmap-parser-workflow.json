{
  "name": "Nmap Scanner with Real Parser",
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "command": "nmap -sV -p 22,80,443,3306,3389,5678 -oX - localhost",
        "options": {}
      },
      "id": "nmap-scan",
      "name": "Nmap XML Output",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [460, 300],
      "notes": "XML í˜•ì‹ìœ¼ë¡œ ì¶œë ¥ (-oX -)"
    },
    {
      "parameters": {
        "jsCode": "// ===== parse-nmap.js í•µì‹¬ ë¡œì§ =====\n\n// Nmap ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°\nconst nmapOutput = $input.first().json.stdout;\n\n// ê°„ì†Œí™”ëœ XML íŒŒì‹± (ì •ê·œí‘œí˜„ì‹ ê¸°ë°˜)\nfunction parseNmapXML(xmlData) {\n  const hosts = [];\n  \n  // <host> ë¸”ë¡ ì¶”ì¶œ\n  const hostRegex = /<host[^>]*>([\\s\\S]*?)<\\/host>/g;\n  let hostMatch;\n  \n  while ((hostMatch = hostRegex.exec(xmlData)) !== null) {\n    const hostBlock = hostMatch[1];\n    \n    // í˜¸ìŠ¤íŠ¸ ìƒíƒœ í™•ì¸\n    const stateMatch = /<status\\s+state=\"([^\"]+)\"/.exec(hostBlock);\n    if (!stateMatch || stateMatch[1] !== 'up') {\n      continue;\n    }\n    \n    // IP ì£¼ì†Œ\n    const addressMatch = /<address\\s+addr=\"([^\"]+)\"\\s+addrtype=\"ipv4\"/.exec(hostBlock);\n    const ip = addressMatch ? addressMatch[1] : 'unknown';\n    \n    // í¬íŠ¸ íŒŒì‹±\n    const ports = [];\n    const portRegex = /<port\\s+protocol=\"([^\"]+)\"\\s+portid=\"([^\"]+)\">([\\s\\S]*?)<\\/port>/g;\n    let portMatch;\n    \n    while ((portMatch = portRegex.exec(hostBlock)) !== null) {\n      const protocol = portMatch[1];\n      const portid = portMatch[2];\n      const portBlock = portMatch[3];\n      \n      // í¬íŠ¸ ìƒíƒœ\n      const portStateMatch = /<state\\s+state=\"([^\"]+)\"/.exec(portBlock);\n      const state = portStateMatch ? portStateMatch[1] : 'unknown';\n      \n      // ì„œë¹„ìŠ¤ ì •ë³´\n      const serviceMatch = /<service\\s+name=\"([^\"]+)\"(?:\\s+product=\"([^\"]*)\")? ?\\/?>/.exec(portBlock);\n      const service = serviceMatch ? serviceMatch[1] : 'unknown';\n      const product = serviceMatch && serviceMatch[2] ? serviceMatch[2] : '';\n      \n      // ìœ„í—˜ë„ í‰ê°€\n      const criticalPorts = ['22', '23', '3389', '5900'];\n      const dbPorts = ['3306', '5432', '1433', '27017'];\n      let risk_level = 'low';\n      \n      if (criticalPorts.includes(portid)) {\n        risk_level = 'critical';\n      } else if (dbPorts.includes(portid)) {\n        risk_level = 'high';\n      } else if (['80', '443', '8080'].includes(portid)) {\n        risk_level = 'medium';\n      }\n      \n      ports.push({\n        port: parseInt(portid),\n        protocol: protocol,\n        state: state,\n        service: service,\n        product: product,\n        risk_level: risk_level\n      });\n    }\n    \n    hosts.push({\n      ip: ip,\n      state: 'up',\n      ports: ports,\n      open_ports_count: ports.filter(p => p.state === 'open').length\n    });\n  }\n  \n  return hosts;\n}\n\n// í†µê³„ ìƒì„±\nfunction generateStatistics(hosts) {\n  let totalPorts = 0;\n  let openPorts = 0;\n  let criticalPorts = 0;\n  let highPorts = 0;\n  \n  hosts.forEach(host => {\n    host.ports.forEach(port => {\n      totalPorts++;\n      if (port.state === 'open') {\n        openPorts++;\n        if (port.risk_level === 'critical') criticalPorts++;\n        else if (port.risk_level === 'high') highPorts++;\n      }\n    });\n  });\n  \n  return {\n    total_hosts: hosts.length,\n    total_ports: totalPorts,\n    open_ports: openPorts,\n    critical_ports: criticalPorts,\n    high_ports: highPorts\n  };\n}\n\n// Slack ë©”ì‹œì§€ ìƒì„±\nfunction generateSlackMessage(hosts, stats) {\n  let message = `ğŸ¤– *Nmap ìŠ¤ìº” ì™„ë£Œ*\\n\\n`;\n  message += `*ì´ í˜¸ìŠ¤íŠ¸:* ${stats.total_hosts}ëŒ€\\n`;\n  message += `*ì—´ë¦° í¬íŠ¸:* ${stats.open_ports}ê°œ\\n`;\n  message += `ğŸ”´ *Critical:* ${stats.critical_ports}ê°œ\\n`;\n  message += `ğŸŸ  *High:* ${stats.high_ports}ê°œ\\n\\n`;\n  \n  if (stats.critical_ports > 0 || stats.high_ports > 0) {\n    message += `*âš ï¸ ì£¼ì˜ í•„ìš” í¬íŠ¸:*\\n`;\n    hosts.forEach(host => {\n      const dangerousPorts = host.ports.filter(p => \n        p.state === 'open' && (p.risk_level === 'critical' || p.risk_level === 'high')\n      );\n      \n      if (dangerousPorts.length > 0) {\n        message += `\\nâ€¢ *${host.ip}*\\n`;\n        dangerousPorts.forEach(port => {\n          message += `  - Port ${port.port}/${port.protocol}: ${port.service} [${port.risk_level.toUpperCase()}]\\n`;\n        });\n      }\n    });\n  }\n  \n  message += `\\n_ìŠ¤ìº” ì‹œê°„: ${new Date().toLocaleString('ko-KR')}_`;\n  \n  return message;\n}\n\n// ë©”ì¸ ì‹¤í–‰\ntry {\n  const hosts = parseNmapXML(nmapOutput);\n  const statistics = generateStatistics(hosts);\n  const slackMessage = generateSlackMessage(hosts, statistics);\n  \n  return {\n    json: {\n      success: true,\n      scan_time: new Date().toISOString(),\n      statistics: statistics,\n      hosts: hosts,\n      slack_message: slackMessage,\n      critical_hosts: hosts.filter(h => \n        h.ports.some(p => p.state === 'open' && p.risk_level === 'critical')\n      )\n    }\n  };\n  \n} catch (error) {\n  return {\n    json: {\n      success: false,\n      error: error.message,\n      timestamp: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "parse-nmap",
      "name": "Parse Nmap (Real Logic)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "notes": "parse-nmap.js ë¡œì§ ì‹¤í–‰"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.statistics.critical_ports }}",
              "operation": "larger",
              "value2": 0
            }
          ]
        }
      },
      "id": "check-critical",
      "name": "Critical í¬íŠ¸ ìˆë‚˜?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// Critical í¬íŠ¸ ë°œê²¬ ì‹œ ê²½ê³  ë©”ì‹œì§€\nconst data = $input.first().json;\n\nconsole.log('âš ï¸ CRITICAL í¬íŠ¸ ë°œê²¬!');\nconsole.log(data.slack_message);\n\nreturn {\n  json: {\n    alert: 'CRITICAL',\n    message: data.slack_message,\n    critical_count: data.statistics.critical_ports,\n    critical_hosts: data.critical_hosts\n  }\n};"
      },
      "id": "alert-critical",
      "name": "âš ï¸ Alert",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 200],
      "notes": "Critical ë°œê²¬ ì‹œ"
    },
    {
      "parameters": {
        "jsCode": "// ì •ìƒ - Critical ì—†ìŒ\nconst data = $input.first().json;\n\nconsole.log('âœ… Critical í¬íŠ¸ ì—†ìŒ');\nconsole.log(data.slack_message);\n\nreturn {\n  json: {\n    status: 'OK',\n    message: data.slack_message,\n    statistics: data.statistics\n  }\n};"
      },
      "id": "no-alert",
      "name": "âœ… OK",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 400],
      "notes": "ì •ìƒ"
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Nmap XML Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Nmap XML Output": {
      "main": [
        [
          {
            "node": "Parse Nmap (Real Logic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Nmap (Real Logic)": {
      "main": [
        [
          {
            "node": "Critical í¬íŠ¸ ìˆë‚˜?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Critical í¬íŠ¸ ìˆë‚˜?": {
      "main": [
        [
          {
            "node": "âš ï¸ Alert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "âœ… OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {},
  "versionId": "1"
}
